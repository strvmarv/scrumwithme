/**
 * Created by Nick Largent on 5/19/14.
 */
var app = angular.module('ScrumWithMe', ['ngCookies']);

app.config(['$locationProvider', function($locationProvider) {
    $locationProvider.html5Mode(true);

}]);

app.run(['$rootScope', function($rootScope) {
    $rootScope.appName = "scrumwith.me";
    $rootScope.appVersion = "20260224.1247";
}]);
/**
 * Created by nslargent on 5/20/14.
 */

angular.module('ScrumWithMe').controller('IndexCtrl', ['$scope', '$window', function ($scope, $window) {

    $scope.sessionid = '';

    $scope.host = function() {
        $window.location = "/host";
    };

    $scope.join = function() {
        $window.location = "/join?session=" + $scope.sessionid.toString().toLowerCase();
    };

}]);
/**
 * Created by Nick Largent on 5/19/14.
 */

angular.module('ScrumWithMe').controller('ClientCtrl', ['$scope', '$location', '$cookieStore', 'socket', 'tools', function ($scope, $location, $cookieStore, socket, tools) {

    var getUser = function() {
        var uid = $cookieStore.get('uid');
        if (uid)
            return uid;
        uid = tools.generateUserId();
        $cookieStore.put('uid', uid);
        return uid;
    };

    var sid = $location.search().session;
    if (sid) {
        sid = sid.toLowerCase();
    }

    var model = {
        uid: getUser(),
        sid: sid,
        qrcodeUrl: '/qrcode?size=1&url=' + encodeURIComponent(tools.buildJoinUrl(sid)),
        qrcodeUrlBig: '/qrcode?size=10&url=' + encodeURIComponent(tools.buildJoinUrl(sid)),
        showSettings: false,
        showConnectCode: false,
        newUsername: '',
        connected: false,
        loggedIn: false,
        roomType: 'unknown',
        transport: 'unknown',
        username: $cookieStore.get('username') || '',
        isLoggedIn: function() {
            return this.username && this.username.length > 0;
        },
        vote: null,
        timerRemaining: 0,
        timerRunning: false
    };
    $scope.model = model;

    $scope.vote = function(value) {
        if (value == model.vote)
            value = null;
        model.vote = value;
        socket.emit('vote', value);
    };

    $scope.showSettings = function() {
        model.newUsername = model.username;
        model.transport = socket.transport();
        model.showSettings = true;
    };

    $scope.showConnectCode = function() {
        model.showConnectCode = !model.showConnectCode;
    };

    $scope.saveSettings = function() {
        $scope.join();
        model.showSettings = false;
    };

    $scope.cancelSettings = function() {
        model.showSettings = false;
    };

    socket.on('connect', function(){
        model.connected = true;
        doJoin();
    });

    socket.on('disconnect', function() {
        model.connected = false;
        model.loggedIn = false;
    });

    socket.on('failure', function(reason) {
        model.connected = false;
        model.loggedIn = false;
        console.log(reason);
        alert(reason);
    });

    socket.on('loggedIn', function() {
        model.loggedIn = true;
    });

    socket.on('roomUpdate', function(room) {
        model.roomType = room.roomType;
    });

    socket.on('reset', function(mode) {
        model.vote = null;
        model.timerRemaining = 0;
        model.timerRunning = false;
    });

    socket.on('timerTick', function(data) {
        model.timerRemaining = data.remaining;
        model.timerRunning = data.running;
    });

    $scope.reset = function() {
        socket.emit("reset");
    };

    $scope.leave = function() {
        socket.emit("leave");
        window.location = "/";
    };

    $scope.join = function() {
        model.username = model.newUsername;
        $cookieStore.put('username', model.newUsername);
        doJoin();
    };

    $scope.connectedIcon = function() {
        if (model.loggedIn)
            return "LED_on.png";
        else
            return "LED_off.png";
    };

    var doJoin = function() {
        if (model.connected && model.username) {
            socket.emit('bindUser', {sid: model.sid, uid: model.uid, username: model.username});
        }
    };
}]);

/**
 * Created by Nick Largent on 5/19/14.
 */

angular.module('ScrumWithMe').controller('ServerCtrl', ['$scope', '$location', '$timeout', '$cookieStore', 'socket', 'tools', function ($scope, $location, $timeout, $cookieStore, socket, tools) {

    $scope.newSession = function() {
        sid = tools.generateSessionId();
        window.location = tools.buildHostUrl(sid);
    };

    var sid =  $location.search().session;

    if (!sid) {
        sid = tools.generateSessionId();
        $location.search("session", sid);
    }
    else {
        sid = sid.toLowerCase();
    }

    var model = {
        sid: sid,
        joinUrl: tools.buildJoinUrl(sid),
        showConnectCode: true,
        roomType: "unknown",
        winningText: "",
        voteStatistics: [],
        qrcodeUrl: '/qrcode?size=3&url=' + encodeURIComponent(tools.buildJoinUrl(sid)),
        qrcodeUrlBig: '/qrcode?size=20&url=' + encodeURIComponent(tools.buildJoinUrl(sid)),
        users: [],
        votedUserCount: 0,
        allIn: false,
        bigRoomMode: 'auto',
        transport: 'unknown',
        copyLinkText: null,
        timerEnabled: false,
        timerDuration: 30,
        timerRemaining: 0,
        timerRunning: false,
    };
    $scope.model = model;
    setInterval(function(){
        $scope.$apply(function() {model.transport = socket.transport();});
    }, 1000);

    $scope.reset = function() {
        socket.emit("reset");
    };

    $scope.kick = function(user) {
        socket.emit("kick", user.uid);
    };

    $scope.setRoomType = function(roomType) {
        socket.emit("setRoomType", roomType);
    };

    $scope.showConnectCode = function() {
        model.showConnectCode = !model.showConnectCode;
    };

    $scope.copyJoinUrl = function() {
        var ta = document.createElement('textarea');
        ta.value = model.joinUrl;
        ta.style.position = 'fixed';
        ta.style.opacity = '0';
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        model.copyLinkText = 'Copied!';
        $timeout(function() { model.copyLinkText = null; }, 2000);
    };

    $scope.toggleTimer = function() {
        model.timerEnabled = !model.timerEnabled;
        socket.emit('setTimerDuration', {
            enabled: model.timerEnabled,
            duration: model.timerDuration
        });
    };

    $scope.sendTimerDuration = function() {
        if (model.timerEnabled) {
            socket.emit('setTimerDuration', {
                enabled: true,
                duration: model.timerDuration
            });
        }
    };

    $scope.isBigRoom = function() {

        switch (model.bigRoomMode) {
            case 'auto':
                return model.users.length > 10;
            case 'off':
                return false;
            case 'on':
                return true;
        }
    };

    $scope.getCardContainerStyle = function() {
        return {'width': (model.users.length * 200) + 'px'};
    };

    var calc_mean = function(list) {
        var total = 0;
        for (var i in list) {
            total += list[i];
        }
        return total / list.length;
    };

    var calc_mode = function(list) {
        var maxValue = "None";
        var maxCount = 0;
        var tieCount = 0;

        for (var i in list) {
            if (list[i] != maxValue) {
                var ct = 0;
                for (var j in list) {
                    if (list[i] == list[j]) {
                        ct++;
                    }
                }

                if (ct > maxCount) {
                    maxCount = ct;
                    maxValue = list[i];
                    tieCount = 0;
                }
                else if (ct == maxCount) {
                    tieCount++;
                }
            }
        }

        return tieCount > 0 ? "Tie" : maxValue;
    };

    var calc_median = function(list) {
        return list[0];
    };

    var getWinningText = function() {
        if (model.allIn) {
            switch (model.roomType) {
                case "planning_poker":
                    break;
                case "tshirt_sizing":
                    break;
                case "relative_sizing":
                    break;
                case "value_pointing":
                case "hours_poker":
                case "days_poker":
                    var list = model.users.filter(function(u) { return u.vote !== 'Pass'; }).map(function (u) {
                        return parseInt(u.vote);
                    });
                    if (list.length === 0) return "";
                    var mean = calc_mean(list);
                    return "Average: " + Math.round(mean * 10.0) / 10.0;
                case "multiple_choice":
                    /*list = model.users.map(function (u) {
                        return u.vote;
                    });
                    var mode = calc_mode(list);
                    return "Winner: " + mode;*/
					break;
				case "fist_of_five":
					break;
            }
        }
        return "";
    };

    var getVoteStatistics = function() {
        var counts = {};

        for (var i in model.users) {
            var vote = model.users[i].vote;
            if (vote !== null) {
                counts[vote] = counts[vote] ? counts[vote]+1 : 1;
            }
        }

        var countList = [];
        for (var j in counts) {
            countList.push({vote: j, count: counts[j], percent: Math.round(counts[j] * 100 / model.users.length)});
        }

        countList.sort(function(a, b) {
            return b.count - a.count;
        });

        return countList;
    };

    socket.on('connect', function(){
        socket.emit('bindHost', {sid: model.sid});
        if (model.timerEnabled) {
            socket.emit('setTimerDuration', {
                enabled: true,
                duration: model.timerDuration
            });
        }
    });

    socket.on('failure', function(reason) {
        console.log(reason);
        alert(reason);
    });

    socket.on('reset', function(mode) {
        model.showConnectCode = false;
    });

    socket.on('timerTick', function(data) {
        model.timerRemaining = data.remaining;
        model.timerRunning = data.running;
    });

    socket.on('dump', function(data) {
        model.roomType = data.roomType;

        var tmpUsers = {};
        for (var i in model.users) {
            tmpUsers[model.users[i].uid] = model.users[i];
        }

        for (i in data.users) {
            var user = data.users[i];
            var existing = tmpUsers[user.uid];
            if (!existing) {
                //console.log("Adding User");
                //console.log(user);
                model.users.push(user);
            }
            else {
                //console.log("Updating User");
                //console.log(user);
                tmpUsers[user.uid].username = user.username;
                tmpUsers[user.uid].orgVote = user.orgVote;
                tmpUsers[user.uid].vote = user.vote;
                tmpUsers[user.uid].connected = user.connected;
                delete tmpUsers[user.uid];
            }
        }

        // delete missing users
        for (var uid in tmpUsers) {
            //console.log("Removing User");
            //console.log(tmpUsers[uid]);
            i = model.users.indexOf(tmpUsers[uid]);
            model.users.splice(i, 1);
        }

        model.users.sort(function(a, b) {
            if(a.username < b.username) return -1;
            if(a.username > b.username) return 1;
            return 0;
        });

        model.allIn = !model.users.some(function(u) { return u.vote === null; });
        model.votedUserCount = model.users.reduce(function(total, x) {return x.vote === null ? total : total + 1;}, 0);
        model.winningText = getWinningText();
        model.voteStatistics = getVoteStatistics();

        if (model.users.length === 0)
            model.showConnectCode = true;

        if (model.users.some(function(u) { return u.vote !== null; }))
            model.showConnectCode = false;
    });

}]);
/**
 * Created by nslargent on 5/20/14.
 */

angular.module('ScrumWithMe').controller('TestCtrl', ['$scope', function ($scope) {

    $scope.username = 'World';

    $scope.sayHello = function() {
        $scope.greeting = 'Hello ' + $scope.username + '!';
    };

}]);
angular.module('ScrumWithMe').factory('socket', ['$rootScope', '$location', function ($rootScope, $location) {
    //console.log($location);
    //var socketUrl = $location.protocol() + "://" + $location.host() + ":4000";
    //var socket = io.connect(socketUrl);
    var socket = io.connect();

    return {
        transport: function() {
            if (socket.io.engine.transport)
                return socket.io.engine.transport.name;
            else
                return "UNKNOWN";
        },
        on: function (eventName, callback) {
            socket.on(eventName, function () {
                var args = arguments;
                $rootScope.$apply(function () {
                    callback.apply(socket, args);
                });
            });
        },
        emit: function (eventName, data, callback) {
            socket.emit(eventName, data, function () {
                var args = arguments;
                $rootScope.$apply(function () {
                    if (callback) {
                        callback.apply(socket, args);
                    }
                });
            });
        }
    };
}]);

/**
 * Created by Nick Largent on 5/23/14.
 */

String.prototype.repeat = function( num )
{
    return new Array( num + 1 ).join( this );
};

angular.module('ScrumWithMe').factory('tools', ['$rootScope', '$location', function ($rootScope, $location) {

    return {

        generateRandomString: function(length, includeLetters, includeNumbers){
            var dict = "";
            if (includeLetters)
                dict += "abcdefghjklmnpqrstuvwxyz";
            if (includeNumbers)
                dict += "123456789";
            var str = 'x'.repeat(length).replace(/[xy]/g, function(c) {
                var r = Math.random()*dict.length;
                return dict.charAt(r);
            });

            return str;
        },

        generateSessionId: function() {
            return this.generateRandomString(6, false, true);
        },

        generateUserId: function() {
            return this.generateRandomString(32, true, true);
        },

        buildHostUrl: function(uuid) {
            var url = window.location.protocol + "//" + window.location.host;
            url += "/host?session=" + uuid;
            return url;
        },

        buildJoinUrl: function(uuid) {
            var url = window.location.protocol + "//" + window.location.host;
            url += "/join?session=" + uuid;
            return url;
        }
    };

}]);